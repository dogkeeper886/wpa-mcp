# 802.1X EAP-TLS Authentication

**Status:** Proposed  
**Created:** 2026-01-13

---

## Goal

Add a new `wifi_connect_tls` tool for EAP-TLS certificate-based authentication. This provides mutual authentication without transmitting passwords.

---

## Current State

The `wifi_connect_eap` tool supports PEAP/TTLS password-based authentication but lacks certificate parameters needed for EAP-TLS.

---

## User Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                     User Requests Connection                     │
│         wifi_connect_tls(ssid, identity, client_cert, ...)      │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Validate Parameters                           │
│  - Zod validates required: ssid, identity, cert PEM strings     │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                 Configure wpa_supplicant                         │
│  - Set key_mgmt=WPA-EAP                                         │
│  - Set eap=TLS                                                  │
│  - Set identity, client_cert, private_key, ca_cert              │
└─────────────────────────────┬───────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Enable & Select Network                       │
│                    Wait for COMPLETED state                      │
└─────────────────────────────┬───────────────────────────────────┘
                              │
              ┌───────────────┴───────────────┐
              ▼                               ▼
       ┌────────────┐                  ┌────────────┐
       │  SUCCESS   │                  │   FAILED   │
       │  Get DHCP  │                  │  Return    │
       │  Return IP │                  │  Error     │
       └────────────┘                  └────────────┘
```

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                         MCP Client                              │
│                  (Claude Desktop / Claude Code)                 │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                   wifi_connect_tls Tool [NEW]                   │
│                                                                 │
│  Parameters:                                                    │
│  ├── ssid              (network name)                          │
│  ├── identity          (CN from client cert)                   │
│  ├── client_cert       (path to client certificate)            │
│  ├── private_key       (path to private key)                   │
│  ├── private_key_password (optional, for encrypted keys)       │
│  ├── ca_cert           (path to CA certificate)                │
│  └── MAC options       (existing randomization support)        │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      WpaCli.connectTls() [NEW]                  │
│                                                                 │
│  wpa_supplicant network configuration:                          │
│  ├── ssid="NetworkName"                                         │
│  ├── key_mgmt=WPA-EAP                                          │
│  ├── eap=TLS                                                   │
│  ├── identity="device.domain.com"                              │
│  ├── client_cert="/path/to/client.crt"                         │
│  ├── private_key="/path/to/client.key"                         │
│  ├── private_key_passwd="keypass" (if encrypted)               │
│  └── ca_cert="/path/to/ca.pem"                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## Authentication Flow

```
┌──────────────┐                         ┌──────────────┐
│    Client    │                         │RADIUS Server │
│ (wpa_suppl)  │                         │              │
└──────┬───────┘                         └──────┬───────┘
       │                                        │
       │  1. EAP-Identity Request               │
       │<───────────────────────────────────────│
       │                                        │
       │  2. EAP-Identity Response              │
       │     (identity from config)             │
       │───────────────────────────────────────>│
       │                                        │
       │  3. Server Certificate                 │
       │<───────────────────────────────────────│
       │                                        │
       │  4. Validate server cert with ca_cert  │
       │     (prevents MITM attacks)            │
       │                                        │
       │  5. Client Certificate + Signature     │
       │     (client_cert + private_key)        │
       │───────────────────────────────────────>│
       │                                        │
       │  6. Server validates client cert       │
       │     (server has root CA)               │
       │                                        │
       │  7. EAP-Success                        │
       │<───────────────────────────────────────│
       │                                        │
       │  No password transmitted               │
       │  Mutual authentication complete        │
       └────────────────────────────────────────┘
```

---

## Features

| Feature | Description |
|---------|-------------|
| Mutual authentication | Both client and server prove identity |
| No password transmission | Credentials never sent over the air |
| Certificate validation | CA cert validates server identity |
| Encrypted private key support | Optional passphrase for key protection |
| MAC randomization | Existing privacy features supported |

---

## Design Decision: Certificate Delivery

MCP server runs remotely, so local file paths won't work. Need to deliver certificates to the server.

### Options Considered

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **A. PEM content in parameters** | Pass cert/key as PEM strings | Simple, no extra setup | Large parameters |
| **B. Pre-deploy to server** | Certs already on server | Secure, standard | Manual setup each time |
| **C. Upload API** | Separate upload endpoint | Flexible | Extra complexity |

### Chosen: Option A - PEM Content

Pass certificate content directly in the tool parameters. Server writes to temp files, uses them, then deletes.

**Rationale:**
- Simplest for MCP client usage
- No manual file transfer needed
- Temp files deleted after connection
- Private key only exists briefly on disk

**Flow:**

```
┌─────────────────┐                    ┌─────────────────┐
│   MCP Client    │                    │   MCP Server    │
│  (Claude Code)  │                    │    (remote)     │
└────────┬────────┘                    └────────┬────────┘
         │                                      │
         │  1. Send PEM content in params       │
         │─────────────────────────────────────>│
         │                                      │
         │                    2. Write to /tmp/ (mode 600)
         │                    3. Configure wpa_supplicant
         │                    4. Connect
         │                    5. Delete temp files
         │                                      │
         │  6. Return success/failure           │
         │<─────────────────────────────────────│
```

**Security considerations:**
- Temp files created with mode 600 (owner read only)
- Files deleted immediately after wpa_supplicant reads them
- Private key exists on disk only briefly

---

## API: wifi_connect_tls

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| ssid | string | Yes | Network SSID |
| identity | string | Yes | Identity (typically CN from client cert) |
| client_cert_pem | string | Yes | PEM-encoded client certificate content |
| private_key_pem | string | Yes | PEM-encoded private key content |
| ca_cert_pem | string | Yes | PEM-encoded CA certificate content |
| private_key_password | string | No | Passphrase for encrypted private key |
| interface | string | No | WiFi interface (default: wlan0) |
| mac_mode | enum | No | MAC randomization mode |
| mac_address | string | No | Specific MAC address |
| preassoc_mac_mode | enum | No | Pre-association MAC mode |
| rand_addr_lifetime | number | No | MAC rotation interval |

### Example

```json
{
  "ssid": "SecureWiFi",
  "identity": "wdca-client-98214785.tsengsyu.com",
  "client_cert_pem": "-----BEGIN CERTIFICATE-----\nMIID...\n-----END CERTIFICATE-----",
  "private_key_pem": "-----BEGIN PRIVATE KEY-----\nMIIE...\n-----END PRIVATE KEY-----",
  "ca_cert_pem": "-----BEGIN CERTIFICATE-----\nMIID...\n-----END CERTIFICATE-----"
}
```

---

## Implementation

### New File: src/lib/cert-manager.ts

Handles temporary certificate file management.

```typescript
import { writeFile, unlink, mkdir } from 'fs/promises';
import { join } from 'path';
import { randomBytes } from 'crypto';

export interface CertFiles {
  clientCert: string;
  privateKey: string;
  caCert: string;
  cleanup: () => Promise<void>;
}

export async function writeTempCerts(
  clientCertPem: string,
  privateKeyPem: string,
  caCertPem: string
): Promise<CertFiles> {
  const tempDir = '/tmp/wpa-mcp-certs';
  const id = randomBytes(8).toString('hex');
  
  await mkdir(tempDir, { recursive: true, mode: 0o700 });
  
  const clientCert = join(tempDir, `client-${id}.crt`);
  const privateKey = join(tempDir, `client-${id}.key`);
  const caCert = join(tempDir, `ca-${id}.crt`);
  
  await writeFile(clientCert, clientCertPem, { mode: 0o600 });
  await writeFile(privateKey, privateKeyPem, { mode: 0o600 });
  await writeFile(caCert, caCertPem, { mode: 0o600 });
  
  const cleanup = async () => {
    await unlink(clientCert).catch(() => {});
    await unlink(privateKey).catch(() => {});
    await unlink(caCert).catch(() => {});
  };
  
  return { clientCert, privateKey, caCert, cleanup };
}
```

### New Method: WpaCli.connectTls()

```typescript
async connectTls(
  ssid: string,
  identity: string,
  clientCertPath: string,
  privateKeyPath: string,
  caCertPath: string,
  privateKeyPassword?: string,
  macConfig?: MacAddressConfig
): Promise<void> {
  const networkIdStr = await this.run('add_network');
  const networkId = parseInt(networkIdStr, 10);

  try {
    await this.run(`set_network ${networkId} ssid '"${ssid}"'`);
    await this.run(`set_network ${networkId} key_mgmt WPA-EAP`);
    await this.run(`set_network ${networkId} eap TLS`);
    await this.run(`set_network ${networkId} identity '"${identity}"'`);
    await this.run(`set_network ${networkId} client_cert '"${clientCertPath}"'`);
    await this.run(`set_network ${networkId} private_key '"${privateKeyPath}"'`);
    await this.run(`set_network ${networkId} ca_cert '"${caCertPath}"'`);

    if (privateKeyPassword) {
      await this.run(`set_network ${networkId} private_key_passwd '"${privateKeyPassword}"'`);
    }

    if (macConfig) {
      await this.applyMacConfig(networkId, macConfig);
    }

    await this.run(`enable_network ${networkId}`);
    await this.run(`select_network ${networkId}`);
    await this.run('save_config');
  } catch (error) {
    await this.run(`remove_network ${networkId}`).catch(() => {});
    throw error;
  }
}
```

### New Tool: wifi_connect_tls

```typescript
server.tool(
  'wifi_connect_tls',
  'Connect to a WPA2-Enterprise network using EAP-TLS certificate authentication. ' +
  'Pass certificate contents as PEM strings. More secure than password-based methods.',
  {
    ssid: z.string().describe('Network SSID'),
    identity: z.string().describe('Identity (typically CN from client certificate)'),
    client_cert_pem: z.string().describe('PEM-encoded client certificate'),
    private_key_pem: z.string().describe('PEM-encoded private key'),
    ca_cert_pem: z.string().describe('PEM-encoded CA certificate'),
    private_key_password: z.string().optional().describe('Passphrase for encrypted private key'),
    interface: z.string().optional().describe('WiFi interface (default: wlan0)'),
    // ... MAC options same as wifi_connect
  },
  async ({ ssid, identity, client_cert_pem, private_key_pem, ca_cert_pem, ... }) => {
    // Write PEM content to temp files
    const certFiles = await writeTempCerts(client_cert_pem, private_key_pem, ca_cert_pem);
    
    try {
      await wpa.connectTls(
        ssid,
        identity,
        certFiles.clientCert,
        certFiles.privateKey,
        certFiles.caCert,
        private_key_password,
        macConfig
      );
      
      // Wait for connection, get DHCP, etc.
      // ...
      
    } finally {
      // Always clean up temp files
      await certFiles.cleanup();
    }
  }
);
```

---

## Files to Modify

| File | Changes |
|------|---------|
| `src/lib/cert-manager.ts` | **NEW** - Temp certificate file management |
| `src/tools/wifi.ts` | Add `wifi_connect_tls` tool |
| `src/lib/wpa-cli.ts` | Add `connectTls()` method |

---

## Testing

### Manual Test

```bash
# Read cert files and pass as PEM content
wifi_connect_tls(
  ssid="TestNetwork",
  identity="wdca-client-98214785.tsengsyu.com",
  client_cert_pem="-----BEGIN CERTIFICATE-----\n...",
  private_key_pem="-----BEGIN PRIVATE KEY-----\n...",
  ca_cert_pem="-----BEGIN CERTIFICATE-----\n..."
)
```

### Verify with wpa_cli

```bash
wpa_cli status
# Should show: key_mgmt=WPA-EAP, EAP state=SUCCESS
```

### Verify temp files cleaned up

```bash
ls /tmp/wpa-mcp-certs/
# Should be empty after connection completes
```

---

## References

- [wpa_supplicant EAP-TLS](https://w1.fi/cgit/hostap/plain/wpa_supplicant/wpa_supplicant.conf)
- [IEEE 802.1X-2020](https://standards.ieee.org/standard/802_1X-2020.html)
